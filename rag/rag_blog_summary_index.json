{
  "index_name": "blog_summary_index",
  "documents": [
    {
      "text": "AKS Scaling Deep Dive â Understanding Your Options AKS provides multiple scaling dimensionsâhorizontal pod scaling, vertical resource adjustment, cluster autoscaling, event-driven scaling, and cross-cluster distributionâeach addressing different aspects of workload management. However, understanding when to apply each mechanism, how they interact, and their respective trade-offs remains challenging for platform teams navigating production deployment decisions. Understanding the capabilities, limitations, and optimal use cases for each AKS scaling mechanism enables informed architectural decisions aligned with specific workload characteristics and operational requirements. The solution requires evaluating six primary scaling approaches and their strategic combinations. Quick Decision Framework Need application-level autoscaling (based on CPU, memory, or custom metrics)? Use HPA (Horizontal Pod Key topics: aks, autoscaling, azure, deployment, hpa",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/aks-scaling/",
        "title": "AKS Scaling Deep Dive â Understanding Your Options",
        "type": "summary"
      }
    },
    {
      "text": "AKS vs Azure Container Apps - Understanding the Architectural Trade-offs Choosing between Azure Kubernetes Service (AKS) and Azure Container Apps (ACA) represents one of the most significant architectural decisions organizations face when adopting containerized applications on Azure. This decision fundamentally impacts development workflows, operational responsibilities, scalability approaches, and long-term platform capabilities. Understanding the specifics of each platform is crucial for making informed architectural decisions. Rather than providing superficial feature comparisons, the solution requires deep technical analysis of capabilities, limitations, and operational implications that directly impact your organization's success with containerized applications. AKS vs ACA Comparison Repository provides structured, detailed analysis across critical decision dimensions including service deployment models, networking architectures, Key topics: aks, azure, container, deployment, kubernetes",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/aks-aca/",
        "title": "AKS vs Azure Container Apps - Understanding the Architectural Trade-offs",
        "type": "summary"
      }
    },
    {
      "text": "Certificates, End-to-End TLS, Cert manager and Service mesh Certificate management in modern distributed systems presents significant challenges that impact security, availability, and operational efficiency. Without proper automation tools like Certbot, cert-manager, or service mesh, organizations face critical issues: Manual Certificate Management Problems: : Expired certificates cause application downtime due to manual renewal processes Security Vulnerabilities : Weak key generation, insecure storage, delayed revocations, and inconsistent policies : Constant monitoring, coordinated renewals, complex deployments, and troubleshooting across infrastructure : Difficulty maintaining audit trails, security standards, and incident response Scalability Limitations : Impossible to manage across microservices, bottlenecks in deployment, configuration drift The evolution from manual certificate management to full Key topics: aks, azure, deployment, envoy, ingress",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/certmanager-tls-servicemesh/",
        "title": "Certificates, End-to-End TLS, Cert manager and Service mesh",
        "type": "summary"
      }
    },
    {
      "text": "MCP Use Case on Azure - Memento Memory Storage Demo The Model Context Protocol (MCP) opens up new possibilities for creating AI-powered applications that can interact with various data sources and services. However, understanding how to deploy MCP servers in cloud environments and integrate them with AI services can be challenging for developers new to the protocol. There's a need for practical examples that demonstrate MCP's capabilities while showcasing real-world deployment patterns on cloud platforms like Azure. Additionally, what if there's a need to provide an interface that uses natural language to store and retrieve data on cloud-backed persistent volumes, such as Azure Files? Traditional file storage interfaces require users Key topics: aks, azure, container, deployment, kubernetes",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/mcpusecaseonazure/",
        "title": "MCP Use Case on Azure - Memento Memory Storage Demo",
        "type": "summary"
      }
    },
    {
      "text": "Model Context Protocol (MCP) - From Hello World to Azure OpenAI Integration What is Model Context Protocol (MCP)? Model Context Protocol (MCP) is an open standard introduced by Anthropic in November 2024 that provides a standardized way for AI models to interact with external tools, data sources, and services in real-time. Instead of AI models being limited to their training data, MCP enables them to access live information, perform calculations, manipulate files, and execute complex workflows through well-defined tool interfaces. This material provides a comprehensive learning journey for MCP, starting from basic concepts and progressing to a production-ready integration with Azure OpenAI. The goal is to demonstrate how MCP can transform AI Key topics: azure, deployment, entraid",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/mcponazure/",
        "title": "Model Context Protocol (MCP) - From Hello World to Azure OpenAI Integration",
        "type": "summary"
      }
    },
    {
      "text": "Using EntraID JWT to verify external calls with Istio add-on on AKS Istio PeerAuthentication CRD helps to authenticate the calls between services in the mesh. However, if you want to authenticate the calls from external services, Istio requires a different CRD which is called RequestAuthentication. How can you configure RequestAuthentication CRD to verify EntraID JWT and allow/deny calls? This CRD helps to authenticate the calls from external services using JWT tokens. This guide will show you how to use RequestAuthentication CRD to authenticate the calls from external services using JWT tokens. RequestAuthentication resource configures the Istio proxy with data extracted from a JWT token. The JWT token is extracted from the request Key topics: aks, authorizationpolicy, entraid, ingress, istio",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/aksistiojwtauth/",
        "title": "Using EntraID JWT to verify external calls with Istio add-on on AKS",
        "type": "summary"
      }
    },
    {
      "text": "Using External Auth with Istio add-on on AKS Istio supports authorization policies that can be used to control access to services. If Istio's built-in authorization policies are not sufficient, you can use external authorization services. This guide will show you how to use an external authorization service with Istio on AKS. With Istio add-on for AKS, you can use an external authorization service to control access to services. You can use a sidecar or a service to implement the external authorization service. This guide will show you how to implement an external authorization service as a sidecar and as a service. High level steps to implement external authz Key topics: aks, container, deployment, istio, service",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/aksistioexternalauth/",
        "title": "Using External Auth with Istio add-on on AKS",
        "type": "summary"
      }
    },
    {
      "text": "Trusted identity but secretless call to APIM In order to prove application identity to Azure API Management (APIM) or any other service, the application needs to present a token. The token can be obtained from Azure Active Directory (AAD) using a client secret or a certificate. However, managing and securing these secrets can be challenging, especially in a cloud-native environment. Workload identity provides a more secure and manageable way to authenticate applications to Azure services. What can be done to leverage workload identity to obtain a token and call APIM or any other service without managing secrets? The blog discusses a specific use case on how to Key topics: aks, azure, container, jwt, kubernetes",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/workloadidentity2apim/",
        "title": "Trusted identity but secretless call to APIM",
        "type": "summary"
      }
    },
    {
      "text": "Azure Container App - Traffic Splitting You have a web application running in Azure Container Apps, and you want to deploy a new version of the application. However, you want to ensure that the new version is stable and does not introduce any issues before fully rolling it out to all users. To achieve this, you want to perform a canary deployment, where a small percentage of traffic is routed to the new version while the majority of traffic continues to go to the existing version. Traffic Splitting in AKS In Azure Kubernetes Service (AKS), traffic splitting is typically achieved using service meshes like Istio or Key topics: aks, azure, container, deployment, ingress",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog6/",
        "title": "Azure Container App - Traffic Splitting",
        "type": "summary"
      }
    },
    {
      "text": "Custom domain and APIM Managing certificates and creating custom domains for Azure services can be a daunting task for many developers and IT professionals. Ensuring secure and reliable access to your services while maintaining control over your domain can be challenging. How can one approach creating custom domains for Azure services, and what steps are involved in verifying domain ownership and routing traffic correctly? Azure provides a streamlined process for creating custom domains, making it easier to manage certificates and ensure secure access to your services. When configuring a custom domain for Azure API Management (APIM), for example, Azure requires you to add specific Key topics: azure, service",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog5/",
        "title": "Custom domain and APIM",
        "type": "summary"
      }
    },
    {
      "text": "SFTP and Azure Blob Storage Many organizations rely on the SFTP (Secure File Transfer Protocol) for secure and reliable file transfers. However, managing and scaling SFTP servers can be complex and resource-intensive. Additionally, integrating SFTP with modern cloud storage solutions like Azure Blob Storage can be challenging, requiring custom solutions and additional infrastructure. Azure Storage account's SFTP feature simplifies this process by providing a fully managed SFTP endpoint that directly integrates with Azure Blob Storage. This feature allows users to securely upload, download, and manage files using the SFTP protocol without the need to manage any underlying infrastructure. By leveraging Azure's scalable and resilient storage, Key topics: azure, scaling",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog4/",
        "title": "SFTP and Azure Blob Storage",
        "type": "summary"
      }
    },
    {
      "text": "AKS Workload Identity in Practice You have an application running in Azure Kubernetes Service (AKS) that needs to access other Azure services. You don't want to use connection string with secrets in the code. You don't want to use service principal with secrets in the code. You want to use managed identities to authenticate to the Azure services. How do you do this in AKS? Two types of identities: Application identities: More ownership, need to create secrets for authentication. Managed identities: Less ownership, no need to create secrets for authentication. (Azure platform manages the secrets). Within managed identities, there are two types: System assigned managed Key topics: aks, azure, container, kubernetes, pod",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog3/",
        "title": "AKS Workload Identity in Practice",
        "type": "summary"
      }
    },
    {
      "text": "Kubernetes as a Service Many open-source projects, such as Apache Flink and Apache Spark, as well as various commercial products, rely heavily on the Kubernetes API for deployment and orchestration. However, general containerized applications do not necessarily require direct interaction with the Kubernetes API and can be abstracted using platforms like Azure Container Apps or custom-built platforms. This abstraction poses a significant challenge for OSS projects and other Kubernetes-dependent applications, as they cannot leverage these simplified platforms without losing essential Kubernetes-specific functionalities. The lack of a unified deployment strategy that accommodates both Kubernetes-dependent and abstracted containerized applications creates operational inefficiencies and complicates the deployment Key topics: aks, azure, container, deployment, kubernetes",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog7/",
        "title": "Kubernetes as a Service",
        "type": "summary"
      }
    },
    {
      "text": "Azure Container Options You need to run containers in Azure. What are the options available to you? What are the pros and cons of each option? How do you choose the right option for your use case? In order to run a program, you need a source code and a runtime environment. This runtime environment can be a virtual machine with an operating system and whatever dependencies are needed to run the program. This is the traditional way of running programs. However, there are other ways to run programs. One of these ways is to use containers. Containers are a way to package Key topics: aks, autoscaling, azure, container, deployment",
      "metadata": {
        "author": "Sridher Manivel",
        "category": "container",
        "url": "https://blog.srinman.com/blog1/",
        "title": "Azure Container Options",
        "type": "summary"
      }
    }
  ]
}